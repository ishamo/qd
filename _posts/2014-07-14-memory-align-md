2014-07-14
---
layout: post
title: C++里面的内存对齐
date:  2014-07-14 13:22:33   
category: C++
tags: memory
---

内存对齐是一个很简单的问题，但是很多C++的书在谈到这一点时不是大书特书，就是草草略过，留给我们无限暇想啊（心中顿时五万头草尼玛奔腾）。

我只想用简单的几句话把这个问题交待清楚，我确定如果你花一分钟，你一定能看懂。

首先，做好心理准备（简单的心理准备）。让我们来建立一种动态的思想，你只要有动态的概念就行了- – 。

这里定义一下结构体：

~~~~~~~
struct A
{
	double f;
	char g;
};
struct B
{
	char a;
	int b;
	char c;
	int d;
	int e;
	A sA;
};
~~~~~~~

那么我们sizeof(B)是多少呢？把这个问题分析完，我相信你一定十分清楚，并且不得痴呆的话是绝对不会忘记的。

以下是对于sizeof(int)的结果是4（即32位系统）的机器来说。

毋庸置疑，sizeof(A)的结果是16，为什么呢？f占8个字节，那么编译器为了时间优化，g也会占8个字节，这样，sizeof(A)的结果就是16了。明白了吗？

在来看sizeof(B).由于f占8个字节，这样，对于B里面的每个变量，内存对齐要求编译器按照这种方式来优化：总是要凑齐8个字节在一起。
a占一个字节，而b占4个字节，为了满足内存优化，a的后面空了三个字节，凑成了4个字节（姑且把这种方式称为局部内存优化吧，全局优化是要满足8个字节），加上b的四个字节，就刚好是8个字节了。接下来我们要继续凑8个字节：char c和int d加在一起（同上）又凑了8个字节，OK，这样对于最后的一个e只占4个字节，但是为了满足全局内存优化，它的后面空了4个字节，跟它一起组成了8个字节。终于把一切都算完了，这样，结构体B到底占多少字节呢？让我们来加一下：8<a+b>+8<c+d>+8<e>+16<f+g> = 40个字节。对照具体的内存方式是这样的：

![memo](http://shamospace.qiniudn.com/memo.jpg)

